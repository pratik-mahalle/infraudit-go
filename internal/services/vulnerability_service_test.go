package services

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/pratik-mahalle/infraudit/internal/domain/vulnerability"
	"github.com/pratik-mahalle/infraudit/internal/pkg/logger"
	"github.com/pratik-mahalle/infraudit/internal/testutil"
)

func TestVulnerabilityService_Create(t *testing.T) {
	repo := testutil.NewMockVulnerabilityRepository()
	log := logger.New(logger.Config{Level: "error", Format: "json"})
	service := NewVulnerabilityService(repo, log, nil, nil)

	tests := []struct {
		name    string
		vuln    *vulnerability.Vulnerability
		wantErr bool
	}{
		{
			name: "create critical vulnerability",
			vuln: &vulnerability.Vulnerability{
				UserID:       1,
				ResourceID:   "i-12345",
				Provider:     vulnerability.ProviderAWS,
				ResourceType: "ec2_instance",
				CVEID:        "CVE-2024-1234",
				Title:        "Remote Code Execution",
				Description:  "Critical RCE vulnerability",
				Severity:     vulnerability.SeverityCritical,
				ScannerType:  vulnerability.ScanTypeTrivy,
				Status:       vulnerability.StatusOpen,
			},
			wantErr: false,
		},
		{
			name: "create high severity vulnerability",
			vuln: &vulnerability.Vulnerability{
				UserID:       1,
				ResourceID:   "bucket-123",
				Provider:     vulnerability.ProviderAWS,
				ResourceType: "s3_bucket",
				Title:        "Public Access Misconfiguration",
				Severity:     vulnerability.SeverityHigh,
				ScannerType:  vulnerability.ScanTypeAWSInspector,
				Status:       vulnerability.StatusOpen,
			},
			wantErr: false,
		},
		{
			name: "create vulnerability with default status",
			vuln: &vulnerability.Vulnerability{
				UserID:       2,
				ResourceID:   "vm-456",
				Provider:     vulnerability.ProviderGCP,
				ResourceType: "compute_instance",
				Title:        "Outdated Package",
				Severity:     vulnerability.SeverityMedium,
				ScannerType:  vulnerability.ScanTypeTrivy,
				// Status empty - should default to StatusOpen
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			id, err := service.Create(ctx, tt.vuln)

			if (err != nil) != tt.wantErr {
				t.Errorf("Create() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if !tt.wantErr && id == 0 {
				t.Error("Create() returned 0 id")
			}
		})
	}
}

func TestVulnerabilityService_GetByID(t *testing.T) {
	repo := testutil.NewMockVulnerabilityRepository()
	log := logger.New(logger.Config{Level: "error", Format: "json"})
	service := NewVulnerabilityService(repo, log, nil, nil)

	ctx := context.Background()
	vuln := &vulnerability.Vulnerability{
		UserID:      1,
		ResourceID:  "test-resource",
		Title:       "Test Vulnerability",
		Severity:    vulnerability.SeverityCritical,
		ScannerType: vulnerability.ScanTypeTrivy,
		Status:      vulnerability.StatusOpen,
	}
	id, _ := service.Create(ctx, vuln)

	tests := []struct {
		name    string
		userID  int64
		vulnID  int64
		wantErr bool
	}{
		{
			name:    "get existing vulnerability",
			userID:  1,
			vulnID:  id,
			wantErr: false,
		},
		{
			name:    "get non-existing vulnerability",
			userID:  1,
			vulnID:  999,
			wantErr: true,
		},
		{
			name:    "get vulnerability for different user",
			userID:  2,
			vulnID:  id,
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v, err := service.GetByID(ctx, tt.userID, tt.vulnID)

			if (err != nil) != tt.wantErr {
				t.Errorf("GetByID() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if !tt.wantErr && v == nil {
				t.Error("GetByID() returned nil vulnerability")
			}
		})
	}
}

func TestVulnerabilityService_UpdateStatus(t *testing.T) {
	repo := testutil.NewMockVulnerabilityRepository()
	log := logger.New(logger.Config{Level: "error", Format: "json"})
	service := NewVulnerabilityService(repo, log, nil, nil)

	ctx := context.Background()
	vuln := &vulnerability.Vulnerability{
		UserID:      1,
		ResourceID:  "test-resource",
		Title:       "Test Vulnerability",
		Severity:    vulnerability.SeverityCritical,
		ScannerType: vulnerability.ScanTypeTrivy,
		Status:      vulnerability.StatusOpen,
	}
	id, _ := service.Create(ctx, vuln)

	tests := []struct {
		name      string
		newStatus string
		wantErr   bool
	}{
		{
			name:      "update to patched",
			newStatus: vulnerability.StatusPatched,
			wantErr:   false,
		},
		{
			name:      "update to ignored",
			newStatus: vulnerability.StatusIgnored,
			wantErr:   false,
		},
		{
			name:      "update to accepted",
			newStatus: vulnerability.StatusAccepted,
			wantErr:   false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := service.UpdateStatus(ctx, 1, id, tt.newStatus)

			if (err != nil) != tt.wantErr {
				t.Errorf("UpdateStatus() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			// Verify status was updated
			updated, _ := service.GetByID(ctx, 1, id)
			if updated.Status != tt.newStatus {
				t.Errorf("UpdateStatus() status = %v, want %v", updated.Status, tt.newStatus)
			}
		})
	}
}

func TestVulnerabilityService_Delete(t *testing.T) {
	repo := testutil.NewMockVulnerabilityRepository()
	log := logger.New(logger.Config{Level: "error", Format: "json"})
	service := NewVulnerabilityService(repo, log, nil, nil)

	ctx := context.Background()
	vuln := &vulnerability.Vulnerability{
		UserID:      1,
		ResourceID:  "to-delete",
		Title:       "To Delete",
		Severity:    vulnerability.SeverityLow,
		ScannerType: vulnerability.ScanTypeNVD,
		Status:      vulnerability.StatusOpen,
	}
	id, _ := service.Create(ctx, vuln)

	// Delete vulnerability
	err := service.Delete(ctx, 1, id)
	if err != nil {
		t.Errorf("Delete() error = %v", err)
	}

	// Verify deletion
	_, err = service.GetByID(ctx, 1, id)
	if err == nil {
		t.Error("Delete() vulnerability still exists after deletion")
	}
}

func TestVulnerabilityService_List(t *testing.T) {
	repo := testutil.NewMockVulnerabilityRepository()
	log := logger.New(logger.Config{Level: "error", Format: "json"})
	service := NewVulnerabilityService(repo, log, nil, nil)

	ctx := context.Background()

	// Create vulnerabilities
	vulns := []*vulnerability.Vulnerability{
		{UserID: 1, ResourceID: "res-1", Title: "Vuln 1", Severity: vulnerability.SeverityCritical, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusOpen},
		{UserID: 1, ResourceID: "res-2", Title: "Vuln 2", Severity: vulnerability.SeverityHigh, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusOpen},
		{UserID: 1, ResourceID: "res-3", Title: "Vuln 3", Severity: vulnerability.SeverityMedium, ScannerType: vulnerability.ScanTypeNVD, Status: vulnerability.StatusPatched},
		{UserID: 2, ResourceID: "res-4", Title: "Vuln 4", Severity: vulnerability.SeverityLow, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusOpen}, // Different user
	}

	for _, v := range vulns {
		service.Create(ctx, v)
	}

	// List all for user 1
	result, total, err := service.List(ctx, 1, vulnerability.Filter{}, 10, 0)
	if err != nil {
		t.Errorf("List() error = %v", err)
		return
	}

	if total != 3 {
		t.Errorf("List() total = %v, want %v", total, 3)
	}

	if len(result) != 3 {
		t.Errorf("List() returned %v vulnerabilities, want %v", len(result), 3)
	}
}

func TestVulnerabilityService_ListWithFilter(t *testing.T) {
	repo := testutil.NewMockVulnerabilityRepository()
	log := logger.New(logger.Config{Level: "error", Format: "json"})
	service := NewVulnerabilityService(repo, log, nil, nil)

	ctx := context.Background()

	// Create vulnerabilities with different severities
	vulns := []*vulnerability.Vulnerability{
		{UserID: 1, ResourceID: "res-1", Title: "Critical 1", Severity: vulnerability.SeverityCritical, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusOpen},
		{UserID: 1, ResourceID: "res-2", Title: "Critical 2", Severity: vulnerability.SeverityCritical, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusOpen},
		{UserID: 1, ResourceID: "res-3", Title: "High 1", Severity: vulnerability.SeverityHigh, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusPatched},
	}

	for _, v := range vulns {
		service.Create(ctx, v)
	}

	// Filter by severity
	result, total, err := service.List(ctx, 1, vulnerability.Filter{Severity: vulnerability.SeverityCritical}, 10, 0)
	if err != nil {
		t.Errorf("List() with filter error = %v", err)
		return
	}

	if total != 2 {
		t.Errorf("List() with severity filter total = %v, want %v", total, 2)
	}

	for _, v := range result {
		if v.Severity != vulnerability.SeverityCritical {
			t.Errorf("List() returned vulnerability with wrong severity: %v", v.Severity)
		}
	}
}

func TestVulnerabilityService_GetSummary(t *testing.T) {
	repo := testutil.NewMockVulnerabilityRepository()
	log := logger.New(logger.Config{Level: "error", Format: "json"})
	service := NewVulnerabilityService(repo, log, nil, nil)

	ctx := context.Background()

	// Create vulnerabilities with different severities
	vulns := []*vulnerability.Vulnerability{
		{UserID: 1, ResourceID: "res-1", Title: "Vuln 1", Severity: vulnerability.SeverityCritical, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusOpen},
		{UserID: 1, ResourceID: "res-2", Title: "Vuln 2", Severity: vulnerability.SeverityCritical, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusOpen},
		{UserID: 1, ResourceID: "res-3", Title: "Vuln 3", Severity: vulnerability.SeverityHigh, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusOpen},
		{UserID: 1, ResourceID: "res-4", Title: "Vuln 4", Severity: vulnerability.SeverityMedium, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusPatched},
		{UserID: 1, ResourceID: "res-5", Title: "Vuln 5", Severity: vulnerability.SeverityLow, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusOpen},
	}

	for _, v := range vulns {
		service.Create(ctx, v)
	}

	summary, err := service.GetSummary(ctx, 1)
	if err != nil {
		t.Errorf("GetSummary() error = %v", err)
		return
	}

	// Check severity summary
	if severitySummary, ok := summary["severity"].(*vulnerability.SeveritySummary); ok {
		if severitySummary.Critical != 2 {
			t.Errorf("GetSummary() critical = %v, want %v", severitySummary.Critical, 2)
		}
		if severitySummary.High != 1 {
			t.Errorf("GetSummary() high = %v, want %v", severitySummary.High, 1)
		}
		if severitySummary.Total != 5 {
			t.Errorf("GetSummary() total = %v, want %v", severitySummary.Total, 5)
		}
	}
}

func TestVulnerabilityService_ListByResource(t *testing.T) {
	repo := testutil.NewMockVulnerabilityRepository()
	log := logger.New(logger.Config{Level: "error", Format: "json"})
	service := NewVulnerabilityService(repo, log, nil, nil)

	ctx := context.Background()

	// Create vulnerabilities for different resources
	vulns := []*vulnerability.Vulnerability{
		{UserID: 1, ResourceID: "resource-a", Title: "Vuln 1", Severity: vulnerability.SeverityCritical, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusOpen},
		{UserID: 1, ResourceID: "resource-a", Title: "Vuln 2", Severity: vulnerability.SeverityHigh, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusOpen},
		{UserID: 1, ResourceID: "resource-b", Title: "Vuln 3", Severity: vulnerability.SeverityMedium, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusOpen},
	}

	for _, v := range vulns {
		service.Create(ctx, v)
	}

	// List by resource
	result, err := service.ListByResource(ctx, 1, "resource-a")
	if err != nil {
		t.Errorf("ListByResource() error = %v", err)
		return
	}

	if len(result) != 2 {
		t.Errorf("ListByResource() returned %v vulnerabilities, want %v", len(result), 2)
	}

	for _, v := range result {
		if v.ResourceID != "resource-a" {
			t.Errorf("ListByResource() returned vulnerability with wrong resource: %v", v.ResourceID)
		}
	}
}

func TestVulnerabilityService_TriggerScan(t *testing.T) {
	repo := testutil.NewMockVulnerabilityRepository()
	log := logger.New(logger.Config{Level: "error", Format: "json"})
	service := NewVulnerabilityService(repo, log, nil, nil)

	ctx := context.Background()

	// Trigger a scan
	scanID, err := service.TriggerScan(ctx, 1, vulnerability.ScanTypeTrivy, "test-resource")
	if err != nil {
		t.Errorf("TriggerScan() error = %v", err)
		return
	}

	if scanID == 0 {
		t.Error("TriggerScan() returned 0 scan ID")
	}

	// Verify scan was created
	scan, err := service.GetScanByID(ctx, 1, scanID)
	if err != nil {
		t.Errorf("GetScanByID() error = %v", err)
		return
	}

	if scan.ScanType != vulnerability.ScanTypeTrivy {
		t.Errorf("TriggerScan() scan type = %v, want %v", scan.ScanType, vulnerability.ScanTypeTrivy)
	}

	if scan.Status != vulnerability.ScanStatusPending {
		t.Errorf("TriggerScan() scan status = %v, want %v", scan.Status, vulnerability.ScanStatusPending)
	}
}

func TestVulnerabilityService_ListScans(t *testing.T) {
	repo := testutil.NewMockVulnerabilityRepository()
	log := logger.New(logger.Config{Level: "error", Format: "json"})
	service := NewVulnerabilityService(repo, log, nil, nil)

	ctx := context.Background()

	// Create multiple scans
	service.TriggerScan(ctx, 1, vulnerability.ScanTypeTrivy, "resource-1")
	service.TriggerScan(ctx, 1, vulnerability.ScanTypeNVD, "resource-2")
	service.TriggerScan(ctx, 2, vulnerability.ScanTypeTrivy, "resource-3") // Different user

	// List scans for user 1
	scans, total, err := service.ListScans(ctx, 1, vulnerability.ScanFilter{}, 10, 0)
	if err != nil {
		t.Errorf("ListScans() error = %v", err)
		return
	}

	if total != 2 {
		t.Errorf("ListScans() total = %v, want %v", total, 2)
	}

	if len(scans) != 2 {
		t.Errorf("ListScans() returned %v scans, want %v", len(scans), 2)
	}
}

func TestVulnerabilityService_GetTopVulnerabilities(t *testing.T) {
	repo := testutil.NewMockVulnerabilityRepository()
	log := logger.New(logger.Config{Level: "error", Format: "json"})
	service := NewVulnerabilityService(repo, log, nil, nil)

	ctx := context.Background()

	// Create vulnerabilities with different severities
	for i := 0; i < 5; i++ {
		service.Create(ctx, &vulnerability.Vulnerability{
			UserID:      1,
			ResourceID:  fmt.Sprintf("res-%d", i),
			Title:       fmt.Sprintf("Critical Vuln %d", i),
			Severity:    vulnerability.SeverityCritical,
			ScannerType: vulnerability.ScanTypeTrivy,
			Status:      vulnerability.StatusOpen,
		})
	}
	service.Create(ctx, &vulnerability.Vulnerability{
		UserID:      1,
		ResourceID:  "res-high",
		Title:       "High Vuln",
		Severity:    vulnerability.SeverityHigh,
		ScannerType: vulnerability.ScanTypeTrivy,
		Status:      vulnerability.StatusOpen,
	})

	// Get top 3 vulnerabilities
	top, err := service.GetTopVulnerabilities(ctx, 1, 3)
	if err != nil {
		t.Errorf("GetTopVulnerabilities() error = %v", err)
		return
	}

	if len(top) > 3 {
		t.Errorf("GetTopVulnerabilities() returned %v, want at most 3", len(top))
	}

	// All should be critical
	for _, v := range top {
		if v.Severity != vulnerability.SeverityCritical {
			t.Errorf("GetTopVulnerabilities() returned non-critical vulnerability")
		}
	}
}

func TestVulnerabilityService_GetResourceSummary(t *testing.T) {
	repo := testutil.NewMockVulnerabilityRepository()
	log := logger.New(logger.Config{Level: "error", Format: "json"})
	service := NewVulnerabilityService(repo, log, nil, nil)

	ctx := context.Background()
	resourceID := "summary-resource"

	// Create vulnerabilities for a specific resource
	vulns := []*vulnerability.Vulnerability{
		{UserID: 1, ResourceID: resourceID, Title: "Vuln 1", Severity: vulnerability.SeverityCritical, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusOpen, DetectedAt: time.Now()},
		{UserID: 1, ResourceID: resourceID, Title: "Vuln 2", Severity: vulnerability.SeverityHigh, ScannerType: vulnerability.ScanTypeTrivy, Status: vulnerability.StatusPatched, DetectedAt: time.Now()},
	}

	for _, v := range vulns {
		service.Create(ctx, v)
	}

	summary, err := service.GetResourceSummary(ctx, 1, resourceID)
	if err != nil {
		t.Errorf("GetResourceSummary() error = %v", err)
		return
	}

	// Check that summary is not nil
	if summary == nil {
		t.Error("GetResourceSummary() returned nil summary")
		return
	}

	// Check total_count with safe type assertion
	if totalCount, ok := summary["total_count"]; ok {
		if tc, ok := totalCount.(int64); ok {
			if tc != 2 {
				t.Errorf("GetResourceSummary() total_count = %v, want 2", tc)
			}
		} else if tc, ok := totalCount.(int); ok {
			if tc != 2 {
				t.Errorf("GetResourceSummary() total_count = %v, want 2", tc)
			}
		}
	}
}
