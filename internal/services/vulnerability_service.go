package services

import (
	"context"
	"fmt"
	"time"

	"infraaudit/backend/internal/domain/vulnerability"
	"infraaudit/backend/internal/pkg/logger"
	"infraaudit/backend/internal/scanners"
)

// VulnerabilityService implements vulnerability.Service interface
type VulnerabilityService struct {
	repo         vulnerability.Repository
	logger       *logger.Logger
	trivyScanner *scanners.TrivyScanner
	nvdScanner   *scanners.NVDScanner
}

// NewVulnerabilityService creates a new vulnerability service
func NewVulnerabilityService(
	repo vulnerability.Repository,
	log *logger.Logger,
	trivyScanner *scanners.TrivyScanner,
	nvdScanner *scanners.NVDScanner,
) vulnerability.Service {
	return &VulnerabilityService{
		repo:         repo,
		logger:       log,
		trivyScanner: trivyScanner,
		nvdScanner:   nvdScanner,
	}
}

// Create creates a new vulnerability
func (s *VulnerabilityService) Create(ctx context.Context, vuln *vulnerability.Vulnerability) (int64, error) {
	if vuln.Status == "" {
		vuln.Status = vulnerability.StatusOpen
	}

	id, err := s.repo.Create(ctx, vuln)
	if err != nil {
		s.logger.WithError(err).Error("Failed to create vulnerability")
		return 0, err
	}

	s.logger.WithFields(map[string]interface{}{
		"vulnerability_id": id,
		"cve_id":          vuln.CVEID,
		"severity":        vuln.Severity,
	}).Info("Vulnerability created")

	return id, nil
}

// GetByID retrieves a vulnerability by ID
func (s *VulnerabilityService) GetByID(ctx context.Context, userID int64, id int64) (*vulnerability.Vulnerability, error) {
	vuln, err := s.repo.GetByID(ctx, userID, id)
	if err != nil {
		s.logger.WithError(err).Error("Failed to get vulnerability")
		return nil, err
	}

	return vuln, nil
}

// Update updates a vulnerability
func (s *VulnerabilityService) Update(ctx context.Context, userID int64, id int64, updates map[string]interface{}) error {
	vuln, err := s.repo.GetByID(ctx, userID, id)
	if err != nil {
		return err
	}

	// Apply updates
	if status, ok := updates["status"].(string); ok {
		vuln.Status = status
		if status == vulnerability.StatusPatched {
			now := time.Now()
			vuln.ResolvedAt = &now
		}
	}
	if remediation, ok := updates["remediation"].(string); ok {
		vuln.Remediation = remediation
	}

	err = s.repo.Update(ctx, vuln)
	if err != nil {
		s.logger.WithError(err).Error("Failed to update vulnerability")
		return err
	}

	s.logger.WithFields(map[string]interface{}{
		"vulnerability_id": id,
		"user_id":         userID,
	}).Info("Vulnerability updated")

	return nil
}

// Delete deletes a vulnerability
func (s *VulnerabilityService) Delete(ctx context.Context, userID int64, id int64) error {
	err := s.repo.Delete(ctx, userID, id)
	if err != nil {
		s.logger.WithError(err).Error("Failed to delete vulnerability")
		return err
	}

	s.logger.WithFields(map[string]interface{}{
		"vulnerability_id": id,
	}).Info("Vulnerability deleted")

	return nil
}

// List retrieves vulnerabilities with filtering and pagination
func (s *VulnerabilityService) List(ctx context.Context, userID int64, filter vulnerability.Filter, limit, offset int) ([]*vulnerability.Vulnerability, int64, error) {
	vulns, total, err := s.repo.ListWithPagination(ctx, userID, filter, limit, offset)
	if err != nil {
		s.logger.WithError(err).Error("Failed to list vulnerabilities")
		return nil, 0, err
	}

	return vulns, total, nil
}

// UpdateStatus updates the status of a vulnerability
func (s *VulnerabilityService) UpdateStatus(ctx context.Context, userID int64, id int64, status string) error {
	var resolvedAt *string
	if status == vulnerability.StatusPatched {
		now := time.Now().Format(time.RFC3339)
		resolvedAt = &now
	}

	err := s.repo.UpdateStatus(ctx, userID, id, status, resolvedAt)
	if err != nil {
		s.logger.WithError(err).Error("Failed to update vulnerability status")
		return err
	}

	s.logger.WithFields(map[string]interface{}{
		"vulnerability_id": id,
		"status":          status,
	}).Info("Vulnerability status updated")

	return nil
}

// GetSummary retrieves vulnerability summary statistics
func (s *VulnerabilityService) GetSummary(ctx context.Context, userID int64) (map[string]interface{}, error) {
	severitySummary, err := s.repo.CountBySeverity(ctx, userID)
	if err != nil {
		s.logger.WithError(err).Error("Failed to get severity summary")
		return nil, err
	}

	statusSummary, err := s.repo.CountByStatus(ctx, userID)
	if err != nil {
		s.logger.WithError(err).Error("Failed to get status summary")
		return nil, err
	}

	summary := map[string]interface{}{
		"by_severity": severitySummary,
		"by_status":   statusSummary,
	}

	return summary, nil
}

// GetTopVulnerabilities retrieves top N critical vulnerabilities
func (s *VulnerabilityService) GetTopVulnerabilities(ctx context.Context, userID int64, limit int) ([]*vulnerability.Vulnerability, error) {
	vulns, err := s.repo.GetTopVulnerabilities(ctx, userID, limit)
	if err != nil {
		s.logger.WithError(err).Error("Failed to get top vulnerabilities")
		return nil, err
	}

	return vulns, nil
}

// ListByResource retrieves vulnerabilities for a specific resource
func (s *VulnerabilityService) ListByResource(ctx context.Context, userID int64, resourceID string) ([]*vulnerability.Vulnerability, error) {
	vulns, err := s.repo.ListByResource(ctx, userID, resourceID)
	if err != nil {
		s.logger.WithError(err).Error("Failed to list vulnerabilities by resource")
		return nil, err
	}

	return vulns, nil
}

// GetResourceSummary retrieves vulnerability summary for a specific resource
func (s *VulnerabilityService) GetResourceSummary(ctx context.Context, userID int64, resourceID string) (map[string]interface{}, error) {
	vulns, err := s.repo.ListByResource(ctx, userID, resourceID)
	if err != nil {
		s.logger.WithError(err).Error("Failed to get resource vulnerabilities")
		return nil, err
	}

	// Count by severity
	severityCounts := map[string]int{
		"critical": 0,
		"high":     0,
		"medium":   0,
		"low":      0,
		"info":     0,
	}

	for _, vuln := range vulns {
		if count, ok := severityCounts[vuln.Severity]; ok {
			severityCounts[vuln.Severity] = count + 1
		}
	}

	summary := map[string]interface{}{
		"total":        len(vulns),
		"by_severity":  severityCounts,
		"resource_id":  resourceID,
	}

	return summary, nil
}

// TriggerScan triggers a vulnerability scan
func (s *VulnerabilityService) TriggerScan(ctx context.Context, userID int64, scanType string, resourceID string) (int64, error) {
	// Create scan record
	scan := &vulnerability.VulnerabilityScan{
		UserID:     userID,
		ResourceID: resourceID,
		ScanType:   scanType,
		Status:     vulnerability.ScanStatusPending,
	}

	scanID, err := s.repo.CreateScan(ctx, scan)
	if err != nil {
		s.logger.WithError(err).Error("Failed to create scan")
		return 0, err
	}

	s.logger.WithFields(map[string]interface{}{
		"scan_id":     scanID,
		"scan_type":   scanType,
		"resource_id": resourceID,
	}).Info("Vulnerability scan triggered")

	// Note: Actual scan would be triggered asynchronously in production
	// For now, we'll just create the scan record

	return scanID, nil
}

// GetScanByID retrieves a scan by ID
func (s *VulnerabilityService) GetScanByID(ctx context.Context, userID int64, scanID int64) (*vulnerability.VulnerabilityScan, error) {
	scan, err := s.repo.GetScanByID(ctx, userID, scanID)
	if err != nil {
		s.logger.WithError(err).Error("Failed to get scan")
		return nil, err
	}

	return scan, nil
}

// ListScans retrieves scans with filtering and pagination
func (s *VulnerabilityService) ListScans(ctx context.Context, userID int64, filter vulnerability.ScanFilter, limit, offset int) ([]*vulnerability.VulnerabilityScan, int64, error) {
	scans, total, err := s.repo.ListScansWithPagination(ctx, userID, filter, limit, offset)
	if err != nil {
		s.logger.WithError(err).Error("Failed to list scans")
		return nil, 0, err
	}

	return scans, total, nil
}

// GetLatestScan retrieves the latest scan for a resource
func (s *VulnerabilityService) GetLatestScan(ctx context.Context, userID int64, resourceID string) (*vulnerability.VulnerabilityScan, error) {
	scan, err := s.repo.GetLatestScan(ctx, userID, resourceID)
	if err != nil {
		s.logger.WithError(err).Error("Failed to get latest scan")
		return nil, err
	}

	return scan, nil
}

// ScanWithTrivy performs a Trivy scan
func (s *VulnerabilityService) ScanWithTrivy(ctx context.Context, userID int64, resourceID string, target string) error {
	s.logger.WithFields(map[string]interface{}{
		"user_id":     userID,
		"resource_id": resourceID,
		"target":      target,
	}).Info("Starting Trivy scan")

	// Create scan record
	startTime := time.Now()
	scan := &vulnerability.VulnerabilityScan{
		UserID:     userID,
		ResourceID: resourceID,
		ScanType:   vulnerability.ScanTypeTrivy,
		Status:     vulnerability.ScanStatusRunning,
		StartedAt:  &startTime,
	}

	scanID, err := s.repo.CreateScan(ctx, scan)
	if err != nil {
		s.logger.WithError(err).Error("Failed to create scan record")
		return err
	}

	// Get scanner version
	version, _ := s.trivyScanner.GetVersion(ctx)
	scan.ScannerVersion = version

	// Perform Trivy scan (example: scanning a container image)
	trivyResult, err := s.trivyScanner.ScanImage(ctx, target)
	if err != nil {
		// Update scan as failed
		completedTime := time.Now()
		scan.Status = vulnerability.ScanStatusFailed
		scan.ErrorMessage = err.Error()
		scan.CompletedAt = &completedTime
		s.repo.UpdateScan(ctx, scan)

		s.logger.WithError(err).Error("Trivy scan failed")
		return err
	}

	// Convert Trivy results to vulnerabilities
	scanTarget := scanners.ScanTarget{
		Type:       "image",
		Target:     target,
		Provider:   vulnerability.ProviderContainer,
		ResourceID: resourceID,
	}

	vulns := s.trivyScanner.ConvertToVulnerabilities(userID, scanID, scanTarget, trivyResult)

	// Save vulnerabilities to database
	severityCounts := map[string]int{
		"critical": 0,
		"high":     0,
		"medium":   0,
		"low":      0,
	}

	for _, vuln := range vulns {
		_, err := s.repo.Create(ctx, vuln)
		if err != nil {
			s.logger.WithError(err).WithFields(map[string]interface{}{
				"cve_id": vuln.CVEID,
			}).Error("Failed to save vulnerability")
			continue
		}

		// Count by severity
		if vuln.Severity == vulnerability.SeverityCritical {
			severityCounts["critical"]++
		} else if vuln.Severity == vulnerability.SeverityHigh {
			severityCounts["high"]++
		} else if vuln.Severity == vulnerability.SeverityMedium {
			severityCounts["medium"]++
		} else if vuln.Severity == vulnerability.SeverityLow {
			severityCounts["low"]++
		}
	}

	// Update scan record with results
	completedTime := time.Now()
	duration := int(completedTime.Sub(startTime).Seconds())

	scan.ID = scanID
	scan.Status = vulnerability.ScanStatusCompleted
	scan.TotalVulnerabilities = len(vulns)
	scan.CriticalCount = severityCounts["critical"]
	scan.HighCount = severityCounts["high"]
	scan.MediumCount = severityCounts["medium"]
	scan.LowCount = severityCounts["low"]
	scan.ScanDuration = &duration
	scan.CompletedAt = &completedTime

	err = s.repo.UpdateScan(ctx, scan)
	if err != nil {
		s.logger.WithError(err).Error("Failed to update scan record")
		return err
	}

	s.logger.WithFields(map[string]interface{}{
		"scan_id":              scanID,
		"total_vulnerabilities": len(vulns),
		"critical":             severityCounts["critical"],
		"high":                 severityCounts["high"],
		"medium":               severityCounts["medium"],
		"low":                  severityCounts["low"],
	}).Info("Trivy scan completed successfully")

	return nil
}

// ScanWithNVD fetches vulnerability data from NVD
func (s *VulnerabilityService) ScanWithNVD(ctx context.Context, userID int64, cveID string) (*vulnerability.Vulnerability, error) {
	s.logger.WithFields(map[string]interface{}{
		"user_id": userID,
		"cve_id":  cveID,
	}).Info("Fetching CVE from NVD")

	// Fetch CVE from NVD
	nvdCVE, err := s.nvdScanner.GetCVEByID(ctx, cveID)
	if err != nil {
		s.logger.WithError(err).Error("Failed to fetch CVE from NVD")
		return nil, err
	}

	// Convert to our vulnerability model
	vuln := s.nvdScanner.ConvertToVulnerability(userID, nil, "", "", nvdCVE)

	// Save to database
	vulnID, err := s.repo.Create(ctx, vuln)
	if err != nil {
		s.logger.WithError(err).Error("Failed to save NVD vulnerability")
		return nil, err
	}

	vuln.ID = vulnID

	s.logger.WithFields(map[string]interface{}{
		"vulnerability_id": vulnID,
		"cve_id":          cveID,
	}).Info("NVD vulnerability saved")

	return vuln, nil
}

// ScanWithCloudNative performs a cloud-native security scan
func (s *VulnerabilityService) ScanWithCloudNative(ctx context.Context, userID int64, provider string, resourceID string) error {
	s.logger.WithFields(map[string]interface{}{
		"user_id":     userID,
		"provider":    provider,
		"resource_id": resourceID,
	}).Info("Starting cloud-native security scan")

	// Create scan record
	startTime := time.Now()
	scan := &vulnerability.VulnerabilityScan{
		UserID:     userID,
		ResourceID: resourceID,
		ScanType:   fmt.Sprintf("%s-native", provider),
		Status:     vulnerability.ScanStatusRunning,
		StartedAt:  &startTime,
	}

	scanID, err := s.repo.CreateScan(ctx, scan)
	if err != nil {
		s.logger.WithError(err).Error("Failed to create scan record")
		return err
	}

	// Note: Cloud-native scanner integration would happen here
	// For now, we'll mark it as completed with a message
	completedTime := time.Now()
	scan.ID = scanID
	scan.Status = vulnerability.ScanStatusCompleted
	scan.ErrorMessage = "Cloud-native scanner integration not yet implemented"
	scan.CompletedAt = &completedTime

	err = s.repo.UpdateScan(ctx, scan)
	if err != nil {
		s.logger.WithError(err).Error("Failed to update scan record")
		return err
	}

	s.logger.Info("Cloud-native scan placeholder completed")

	return nil
}
