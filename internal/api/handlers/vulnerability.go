package handlers

import (
	"encoding/json"
	"net/http"
	"strconv"

	"github.com/go-chi/chi/v5"
	"github.com/pratik-mahalle/infraudit/internal/api/dto"
	"github.com/pratik-mahalle/infraudit/internal/api/middleware"
	"github.com/pratik-mahalle/infraudit/internal/domain/vulnerability"
	"github.com/pratik-mahalle/infraudit/internal/pkg/errors"
	"github.com/pratik-mahalle/infraudit/internal/pkg/logger"
	"github.com/pratik-mahalle/infraudit/internal/pkg/utils"
	"github.com/pratik-mahalle/infraudit/internal/pkg/validator"
)

// VulnerabilityHandler handles vulnerability-related HTTP requests
type VulnerabilityHandler struct {
	service   vulnerability.Service
	logger    *logger.Logger
	validator *validator.Validator
}

// NewVulnerabilityHandler creates a new vulnerability handler
func NewVulnerabilityHandler(service vulnerability.Service, log *logger.Logger, val *validator.Validator) *VulnerabilityHandler {
	return &VulnerabilityHandler{
		service:   service,
		logger:    log,
		validator: val,
	}
}

// List handles GET /api/v1/vulnerabilities
// @Summary List vulnerabilities
// @Description Get a paginated list of vulnerabilities with optional filtering
// @Tags Vulnerabilities
// @Produce json
// @Param severity query string false "Filter by severity"
// @Param status query string false "Filter by status"
// @Param provider query string false "Filter by provider"
// @Param resource_id query string false "Filter by resource ID"
// @Param resource_type query string false "Filter by resource type"
// @Param scanner_type query string false "Filter by scanner type"
// @Param cve_id query string false "Filter by CVE ID"
// @Param min_cvss query number false "Minimum CVSS score"
// @Param max_cvss query number false "Maximum CVSS score"
// @Param page query int false "Page number (default: 1)"
// @Param page_size query int false "Page size (default: 20, max: 100)"
// @Success 200 {object} utils.PaginatedResponse{data=[]dto.VulnerabilityDTO} "List of vulnerabilities"
// @Failure 500 {object} utils.ErrorResponse "Internal server error"
// @Security BearerAuth
// @Router /vulnerabilities [get]
func (h *VulnerabilityHandler) List(w http.ResponseWriter, r *http.Request) {
	userID, _ := middleware.GetUserID(r)

	// Parse pagination parameters
	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	pageSize, _ := strconv.Atoi(r.URL.Query().Get("page_size"))
	if page < 1 {
		page = 1
	}
	if pageSize < 1 || pageSize > 100 {
		pageSize = 20
	}

	// Parse filter parameters
	filter := vulnerability.Filter{
		Severity:     r.URL.Query().Get("severity"),
		Status:       r.URL.Query().Get("status"),
		Provider:     r.URL.Query().Get("provider"),
		ResourceID:   r.URL.Query().Get("resource_id"),
		ResourceType: r.URL.Query().Get("resource_type"),
		ScannerType:  r.URL.Query().Get("scanner_type"),
		CVEID:        r.URL.Query().Get("cve_id"),
	}

	// Parse CVSS score range
	if minCVSS := r.URL.Query().Get("min_cvss"); minCVSS != "" {
		if score, err := strconv.ParseFloat(minCVSS, 64); err == nil {
			filter.MinCVSS = &score
		}
	}
	if maxCVSS := r.URL.Query().Get("max_cvss"); maxCVSS != "" {
		if score, err := strconv.ParseFloat(maxCVSS, 64); err == nil {
			filter.MaxCVSS = &score
		}
	}

	offset := (page - 1) * pageSize
	vulns, total, err := h.service.List(r.Context(), userID, filter, pageSize, offset)
	if err != nil {
		utils.WriteError(w, errors.Internal("Failed to list vulnerabilities", err))
		return
	}

	// Convert to DTOs
	dtos := make([]dto.VulnerabilityDTO, len(vulns))
	for i, v := range vulns {
		dtos[i] = dto.VulnerabilityDTO{
			ID:               v.ID,
			ResourceID:       v.ResourceID,
			Provider:         v.Provider,
			ResourceType:     v.ResourceType,
			CVEID:            v.CVEID,
			VulnerabilityID:  v.VulnerabilityID,
			Title:            v.Title,
			Description:      v.Description,
			Severity:         v.Severity,
			CVSSScore:        v.CVSSScore,
			CVSSVector:       v.CVSSVector,
			PackageName:      v.PackageName,
			PackageVersion:   v.PackageVersion,
			FixedVersion:     v.FixedVersion,
			PackageType:      v.PackageType,
			ScannerType:      v.ScannerType,
			Status:           v.Status,
			Remediation:      v.Remediation,
			PublishedDate:    v.PublishedDate,
			LastModifiedDate: v.LastModifiedDate,
			DetectedAt:       v.DetectedAt,
			ResolvedAt:       v.ResolvedAt,
		}
	}

	utils.WriteSuccess(w, http.StatusOK, utils.NewPaginatedResponse(dtos, page, pageSize, total))
}

// Get handles GET /api/v1/vulnerabilities/{id}
// @Summary Get vulnerability by ID
// @Description Get detailed information about a specific vulnerability
// @Tags Vulnerabilities
// @Produce json
// @Param id path int true "Vulnerability ID"
// @Success 200 {object} dto.VulnerabilityDTO "Vulnerability details"
// @Failure 404 {object} utils.ErrorResponse "Vulnerability not found"
// @Failure 500 {object} utils.ErrorResponse "Internal server error"
// @Security BearerAuth
// @Router /vulnerabilities/{id} [get]
func (h *VulnerabilityHandler) Get(w http.ResponseWriter, r *http.Request) {
	userID, _ := middleware.GetUserID(r)
	id, _ := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)

	vuln, err := h.service.GetByID(r.Context(), userID, id)
	if err != nil {
		if appErr, ok := err.(*errors.AppError); ok {
			utils.WriteError(w, appErr)
		} else {
			utils.WriteError(w, errors.Internal("Failed to get vulnerability", err))
		}
		return
	}

	utils.WriteSuccess(w, http.StatusOK, dto.VulnerabilityDTO{
		ID:               vuln.ID,
		ResourceID:       vuln.ResourceID,
		Provider:         vuln.Provider,
		ResourceType:     vuln.ResourceType,
		CVEID:            vuln.CVEID,
		VulnerabilityID:  vuln.VulnerabilityID,
		Title:            vuln.Title,
		Description:      vuln.Description,
		Severity:         vuln.Severity,
		CVSSScore:        vuln.CVSSScore,
		CVSSVector:       vuln.CVSSVector,
		PackageName:      vuln.PackageName,
		PackageVersion:   vuln.PackageVersion,
		FixedVersion:     vuln.FixedVersion,
		PackageType:      vuln.PackageType,
		ScannerType:      vuln.ScannerType,
		Status:           vuln.Status,
		Remediation:      vuln.Remediation,
		PublishedDate:    vuln.PublishedDate,
		LastModifiedDate: vuln.LastModifiedDate,
		DetectedAt:       vuln.DetectedAt,
		ResolvedAt:       vuln.ResolvedAt,
	})
}

// UpdateStatus handles PUT /api/v1/vulnerabilities/{id}/status
// @Summary Update vulnerability status
// @Description Update the status of a specific vulnerability
// @Tags Vulnerabilities
// @Accept json
// @Produce json
// @Param id path int true "Vulnerability ID"
// @Param request body dto.UpdateVulnerabilityStatusRequest true "Status update"
// @Success 200 {object} map[string]interface{} "Status updated successfully"
// @Failure 400 {object} utils.ErrorResponse "Invalid request or validation error"
// @Failure 500 {object} utils.ErrorResponse "Internal server error"
// @Security BearerAuth
// @Router /vulnerabilities/{id}/status [put]
func (h *VulnerabilityHandler) UpdateStatus(w http.ResponseWriter, r *http.Request) {
	userID, _ := middleware.GetUserID(r)
	id, _ := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)

	var req dto.UpdateVulnerabilityStatusRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.WriteError(w, errors.BadRequest("Invalid request body"))
		return
	}

	if errs := h.validator.Validate(req); len(errs) > 0 {
		utils.WriteError(w, errors.ValidationError("Validation failed", errs))
		return
	}

	err := h.service.UpdateStatus(r.Context(), userID, id, req.Status)
	if err != nil {
		utils.WriteError(w, errors.Internal("Failed to update vulnerability status", err))
		return
	}

	utils.WriteSuccess(w, http.StatusOK, map[string]interface{}{
		"message": "Vulnerability status updated successfully",
	})
}

// Delete handles DELETE /api/v1/vulnerabilities/{id}
// @Summary Delete vulnerability
// @Description Delete a vulnerability by ID
// @Tags Vulnerabilities
// @Produce json
// @Param id path int true "Vulnerability ID"
// @Success 200 {object} map[string]interface{} "Vulnerability deleted successfully"
// @Failure 500 {object} utils.ErrorResponse "Internal server error"
// @Security BearerAuth
// @Router /vulnerabilities/{id} [delete]
func (h *VulnerabilityHandler) Delete(w http.ResponseWriter, r *http.Request) {
	userID, _ := middleware.GetUserID(r)
	id, _ := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)

	err := h.service.Delete(r.Context(), userID, id)
	if err != nil {
		utils.WriteError(w, errors.Internal("Failed to delete vulnerability", err))
		return
	}

	utils.WriteSuccess(w, http.StatusOK, map[string]interface{}{
		"message": "Vulnerability deleted successfully",
	})
}

// GetSummary handles GET /api/v1/vulnerabilities/summary
// @Summary Get vulnerability summary
// @Description Get summary statistics of vulnerabilities
// @Tags Vulnerabilities
// @Produce json
// @Success 200 {object} map[string]interface{} "Vulnerability summary"
// @Failure 500 {object} utils.ErrorResponse "Internal server error"
// @Security BearerAuth
// @Router /vulnerabilities/summary [get]
func (h *VulnerabilityHandler) GetSummary(w http.ResponseWriter, r *http.Request) {
	userID, _ := middleware.GetUserID(r)

	summary, err := h.service.GetSummary(r.Context(), userID)
	if err != nil {
		utils.WriteError(w, errors.Internal("Failed to get vulnerability summary", err))
		return
	}

	utils.WriteSuccess(w, http.StatusOK, summary)
}

// GetTopVulnerabilities handles GET /api/v1/vulnerabilities/top
// @Summary Get top vulnerabilities
// @Description Get the top N vulnerabilities by severity
// @Tags Vulnerabilities
// @Produce json
// @Param limit query int false "Number of vulnerabilities to return (default: 10, max: 100)"
// @Success 200 {array} dto.VulnerabilityDTO "List of top vulnerabilities"
// @Failure 500 {object} utils.ErrorResponse "Internal server error"
// @Security BearerAuth
// @Router /vulnerabilities/top [get]
func (h *VulnerabilityHandler) GetTopVulnerabilities(w http.ResponseWriter, r *http.Request) {
	userID, _ := middleware.GetUserID(r)

	limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
	if limit < 1 || limit > 100 {
		limit = 10
	}

	vulns, err := h.service.GetTopVulnerabilities(r.Context(), userID, limit)
	if err != nil {
		utils.WriteError(w, errors.Internal("Failed to get top vulnerabilities", err))
		return
	}

	// Convert to DTOs
	dtos := make([]dto.VulnerabilityDTO, len(vulns))
	for i, v := range vulns {
		dtos[i] = dto.VulnerabilityDTO{
			ID:               v.ID,
			ResourceID:       v.ResourceID,
			Provider:         v.Provider,
			ResourceType:     v.ResourceType,
			CVEID:            v.CVEID,
			VulnerabilityID:  v.VulnerabilityID,
			Title:            v.Title,
			Description:      v.Description,
			Severity:         v.Severity,
			CVSSScore:        v.CVSSScore,
			CVSSVector:       v.CVSSVector,
			PackageName:      v.PackageName,
			PackageVersion:   v.PackageVersion,
			FixedVersion:     v.FixedVersion,
			PackageType:      v.PackageType,
			ScannerType:      v.ScannerType,
			Status:           v.Status,
			Remediation:      v.Remediation,
			PublishedDate:    v.PublishedDate,
			LastModifiedDate: v.LastModifiedDate,
			DetectedAt:       v.DetectedAt,
			ResolvedAt:       v.ResolvedAt,
		}
	}

	utils.WriteSuccess(w, http.StatusOK, dtos)
}

// GetByResource handles GET /api/v1/vulnerabilities/resource/{resourceId}
// @Summary Get vulnerabilities by resource
// @Description Get all vulnerabilities for a specific resource
// @Tags Vulnerabilities
// @Produce json
// @Param resourceId path string true "Resource ID"
// @Success 200 {array} dto.VulnerabilityDTO "List of resource vulnerabilities"
// @Failure 500 {object} utils.ErrorResponse "Internal server error"
// @Security BearerAuth
// @Router /vulnerabilities/resource/{resourceId} [get]
func (h *VulnerabilityHandler) GetByResource(w http.ResponseWriter, r *http.Request) {
	userID, _ := middleware.GetUserID(r)
	resourceID := chi.URLParam(r, "resourceId")

	vulns, err := h.service.ListByResource(r.Context(), userID, resourceID)
	if err != nil {
		utils.WriteError(w, errors.Internal("Failed to get resource vulnerabilities", err))
		return
	}

	// Convert to DTOs
	dtos := make([]dto.VulnerabilityDTO, len(vulns))
	for i, v := range vulns {
		dtos[i] = dto.VulnerabilityDTO{
			ID:               v.ID,
			ResourceID:       v.ResourceID,
			Provider:         v.Provider,
			ResourceType:     v.ResourceType,
			CVEID:            v.CVEID,
			VulnerabilityID:  v.VulnerabilityID,
			Title:            v.Title,
			Description:      v.Description,
			Severity:         v.Severity,
			CVSSScore:        v.CVSSScore,
			CVSSVector:       v.CVSSVector,
			PackageName:      v.PackageName,
			PackageVersion:   v.PackageVersion,
			FixedVersion:     v.FixedVersion,
			PackageType:      v.PackageType,
			ScannerType:      v.ScannerType,
			Status:           v.Status,
			Remediation:      v.Remediation,
			PublishedDate:    v.PublishedDate,
			LastModifiedDate: v.LastModifiedDate,
			DetectedAt:       v.DetectedAt,
			ResolvedAt:       v.ResolvedAt,
		}
	}

	utils.WriteSuccess(w, http.StatusOK, dtos)
}

// TriggerScan handles POST /api/v1/vulnerabilities/scan
// @Summary Trigger vulnerability scan
// @Description Trigger a vulnerability scan using specified scanner type
// @Tags Vulnerabilities
// @Accept json
// @Produce json
// @Param request body dto.TriggerScanRequest true "Scan configuration"
// @Success 200 {object} map[string]interface{} "Scan triggered successfully"
// @Failure 400 {object} utils.ErrorResponse "Invalid request or validation error"
// @Failure 500 {object} utils.ErrorResponse "Internal server error"
// @Security BearerAuth
// @Router /vulnerabilities/scan [post]
func (h *VulnerabilityHandler) TriggerScan(w http.ResponseWriter, r *http.Request) {
	userID, _ := middleware.GetUserID(r)

	var req dto.TriggerScanRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.WriteError(w, errors.BadRequest("Invalid request body"))
		return
	}

	if errs := h.validator.Validate(req); len(errs) > 0 {
		utils.WriteError(w, errors.ValidationError("Validation failed", errs))
		return
	}

	// Trigger scan based on type
	var err error
	switch req.ScanType {
	case vulnerability.ScanTypeTrivy:
		if req.Target == "" {
			utils.WriteError(w, errors.BadRequest("Target is required for Trivy scans"))
			return
		}
		err = h.service.ScanWithTrivy(r.Context(), userID, req.ResourceID, req.Target)
	case vulnerability.ScanTypeNVD:
		// For NVD, we expect a CVE ID in the target field
		if req.Target == "" {
			utils.WriteError(w, errors.BadRequest("CVE ID is required for NVD lookups"))
			return
		}
		_, err = h.service.ScanWithNVD(r.Context(), userID, req.Target)
	case vulnerability.ScanTypeAWSInspector, vulnerability.ScanTypeGCPSCC, vulnerability.ScanTypeAzureSC:
		if req.Provider == "" || req.ResourceID == "" {
			utils.WriteError(w, errors.BadRequest("Provider and resource_id are required for cloud-native scans"))
			return
		}
		err = h.service.ScanWithCloudNative(r.Context(), userID, req.Provider, req.ResourceID)
	default:
		utils.WriteError(w, errors.BadRequest("Invalid scan type"))
		return
	}

	if err != nil {
		utils.WriteError(w, errors.Internal("Failed to trigger scan", err))
		return
	}

	utils.WriteSuccess(w, http.StatusOK, map[string]interface{}{
		"message": "Scan triggered successfully",
	})
}

// ListScans handles GET /api/v1/vulnerabilities/scans
// @Summary List vulnerability scans
// @Description Get a paginated list of vulnerability scans with optional filtering
// @Tags Vulnerabilities
// @Produce json
// @Param scan_type query string false "Filter by scan type"
// @Param status query string false "Filter by status"
// @Param resource_id query string false "Filter by resource ID"
// @Param page query int false "Page number (default: 1)"
// @Param page_size query int false "Page size (default: 20, max: 100)"
// @Success 200 {object} utils.PaginatedResponse{data=[]dto.VulnerabilityScanDTO} "List of scans"
// @Failure 500 {object} utils.ErrorResponse "Internal server error"
// @Security BearerAuth
// @Router /vulnerabilities/scans [get]
func (h *VulnerabilityHandler) ListScans(w http.ResponseWriter, r *http.Request) {
	userID, _ := middleware.GetUserID(r)

	// Parse pagination parameters
	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	pageSize, _ := strconv.Atoi(r.URL.Query().Get("page_size"))
	if page < 1 {
		page = 1
	}
	if pageSize < 1 || pageSize > 100 {
		pageSize = 20
	}

	// Parse filter parameters
	filter := vulnerability.ScanFilter{
		ScanType:   r.URL.Query().Get("scan_type"),
		Status:     r.URL.Query().Get("status"),
		ResourceID: r.URL.Query().Get("resource_id"),
	}

	offset := (page - 1) * pageSize
	scans, total, err := h.service.ListScans(r.Context(), userID, filter, pageSize, offset)
	if err != nil {
		utils.WriteError(w, errors.Internal("Failed to list scans", err))
		return
	}

	// Convert to DTOs
	dtos := make([]dto.VulnerabilityScanDTO, len(scans))
	for i, s := range scans {
		dtos[i] = dto.VulnerabilityScanDTO{
			ID:                   s.ID,
			ResourceID:           s.ResourceID,
			ScanType:             s.ScanType,
			Status:               s.Status,
			ScannerVersion:       s.ScannerVersion,
			TotalVulnerabilities: s.TotalVulnerabilities,
			CriticalCount:        s.CriticalCount,
			HighCount:            s.HighCount,
			MediumCount:          s.MediumCount,
			LowCount:             s.LowCount,
			ScanDuration:         s.ScanDuration,
			ErrorMessage:         s.ErrorMessage,
			StartedAt:            s.StartedAt,
			CompletedAt:          s.CompletedAt,
			CreatedAt:            s.CreatedAt,
		}
	}

	utils.WriteSuccess(w, http.StatusOK, utils.NewPaginatedResponse(dtos, page, pageSize, total))
}

// GetScan handles GET /api/v1/vulnerabilities/scans/{id}
// @Summary Get vulnerability scan by ID
// @Description Get detailed information about a specific vulnerability scan
// @Tags Vulnerabilities
// @Produce json
// @Param id path int true "Scan ID"
// @Success 200 {object} dto.VulnerabilityScanDTO "Scan details"
// @Failure 404 {object} utils.ErrorResponse "Scan not found"
// @Failure 500 {object} utils.ErrorResponse "Internal server error"
// @Security BearerAuth
// @Router /vulnerabilities/scans/{id} [get]
func (h *VulnerabilityHandler) GetScan(w http.ResponseWriter, r *http.Request) {
	userID, _ := middleware.GetUserID(r)
	id, _ := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)

	scan, err := h.service.GetScanByID(r.Context(), userID, id)
	if err != nil {
		if appErr, ok := err.(*errors.AppError); ok {
			utils.WriteError(w, appErr)
		} else {
			utils.WriteError(w, errors.Internal("Failed to get scan", err))
		}
		return
	}

	utils.WriteSuccess(w, http.StatusOK, dto.VulnerabilityScanDTO{
		ID:                   scan.ID,
		ResourceID:           scan.ResourceID,
		ScanType:             scan.ScanType,
		Status:               scan.Status,
		ScannerVersion:       scan.ScannerVersion,
		TotalVulnerabilities: scan.TotalVulnerabilities,
		CriticalCount:        scan.CriticalCount,
		HighCount:            scan.HighCount,
		MediumCount:          scan.MediumCount,
		LowCount:             scan.LowCount,
		ScanDuration:         scan.ScanDuration,
		ErrorMessage:         scan.ErrorMessage,
		StartedAt:            scan.StartedAt,
		CompletedAt:          scan.CompletedAt,
		CreatedAt:            scan.CreatedAt,
	})
}
