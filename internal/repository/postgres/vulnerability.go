package postgres

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/pratik-mahalle/infraudit/internal/domain/vulnerability"
)

// VulnerabilityRepository implements vulnerability.Repository interface
type VulnerabilityRepository struct {
	db *sql.DB
}

// NewVulnerabilityRepository creates a new vulnerability repository
func NewVulnerabilityRepository(db *sql.DB) vulnerability.Repository {
	return &VulnerabilityRepository{db: db}
}

// rebindQuery converts ? placeholders to $1, $2, etc for PostgreSQL
// This is a simple implementation that works for positional parameters
func rebindQuery(query string) string {
	n := 1
	result := strings.Builder{}
	for _, ch := range query {
		if ch == '?' {
			result.WriteString(fmt.Sprintf("$%d", n))
			n++
		} else {
			result.WriteRune(ch)
		}
	}
	return result.String()
}

// Create inserts a new vulnerability
func (r *VulnerabilityRepository) Create(ctx context.Context, vuln *vulnerability.Vulnerability) (int64, error) {
	query := `
		INSERT INTO vulnerabilities (
			user_id, scan_id, resource_id, provider, resource_type,
			cve_id, vulnerability_id, title, description,
			severity, cvss_score, cvss_vector,
			package_name, package_version, fixed_version, package_type,
			scanner_type, detection_method, status, remediation, reference_urls,
			published_date, last_modified_date, detected_at
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	`

	result, err := r.db.ExecContext(ctx, query,
		vuln.UserID, vuln.ScanID, vuln.ResourceID, vuln.Provider, vuln.ResourceType,
		vuln.CVEID, vuln.VulnerabilityID, vuln.Title, vuln.Description,
		vuln.Severity, vuln.CVSSScore, vuln.CVSSVector,
		vuln.PackageName, vuln.PackageVersion, vuln.FixedVersion, vuln.PackageType,
		vuln.ScannerType, vuln.DetectionMethod, vuln.Status, vuln.Remediation, vuln.ReferenceURLs,
		vuln.PublishedDate, vuln.LastModifiedDate, vuln.DetectedAt,
	)

	if err != nil {
		return 0, fmt.Errorf("failed to create vulnerability: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return 0, fmt.Errorf("failed to get last insert id: %w", err)
	}

	return id, nil
}

// CreateBatch inserts multiple vulnerabilities in a single transaction
func (r *VulnerabilityRepository) CreateBatch(ctx context.Context, vulns []*vulnerability.Vulnerability) error {
	if len(vulns) == 0 {
		return nil
	}

	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	// Start with ? placeholders and convert to $1, $2, ... for PostgreSQL compatibility
	query := `
		INSERT INTO vulnerabilities (
			user_id, scan_id, resource_id, provider, resource_type,
			cve_id, vulnerability_id, title, description,
			severity, cvss_score, cvss_vector,
			package_name, package_version, fixed_version, package_type,
			scanner_type, detection_method, status, remediation, reference_urls,
			published_date, last_modified_date, detected_at
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	`

	// Convert to PostgreSQL-style placeholders ($1, $2, ...) for lib/pq driver
	query = rebindQuery(query)

	stmt, err := tx.PrepareContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to prepare statement: %w", err)
	}
	defer stmt.Close()

	for _, vuln := range vulns {
		_, err := stmt.ExecContext(ctx,
			vuln.UserID, vuln.ScanID, vuln.ResourceID, vuln.Provider, vuln.ResourceType,
			vuln.CVEID, vuln.VulnerabilityID, vuln.Title, vuln.Description,
			vuln.Severity, vuln.CVSSScore, vuln.CVSSVector,
			vuln.PackageName, vuln.PackageVersion, vuln.FixedVersion, vuln.PackageType,
			vuln.ScannerType, vuln.DetectionMethod, vuln.Status, vuln.Remediation, vuln.ReferenceURLs,
			vuln.PublishedDate, vuln.LastModifiedDate, vuln.DetectedAt,
		)
		if err != nil {
			return fmt.Errorf("failed to insert vulnerability %s: %w", vuln.CVEID, err)
		}
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}

// GetByID retrieves a vulnerability by ID
func (r *VulnerabilityRepository) GetByID(ctx context.Context, userID int64, id int64) (*vulnerability.Vulnerability, error) {
	query := `
		SELECT id, user_id, scan_id, resource_id, provider, resource_type,
			cve_id, vulnerability_id, title, description,
			severity, cvss_score, cvss_vector,
			package_name, package_version, fixed_version, package_type,
			scanner_type, detection_method, status, remediation, reference_urls,
			published_date, last_modified_date, detected_at, resolved_at,
			created_at, updated_at
		FROM vulnerabilities
		WHERE id = ? AND user_id = ?
	`

	vuln := &vulnerability.Vulnerability{}
	err := r.db.QueryRowContext(ctx, query, id, userID).Scan(
		&vuln.ID, &vuln.UserID, &vuln.ScanID, &vuln.ResourceID, &vuln.Provider, &vuln.ResourceType,
		&vuln.CVEID, &vuln.VulnerabilityID, &vuln.Title, &vuln.Description,
		&vuln.Severity, &vuln.CVSSScore, &vuln.CVSSVector,
		&vuln.PackageName, &vuln.PackageVersion, &vuln.FixedVersion, &vuln.PackageType,
		&vuln.ScannerType, &vuln.DetectionMethod, &vuln.Status, &vuln.Remediation, &vuln.ReferenceURLs,
		&vuln.PublishedDate, &vuln.LastModifiedDate, &vuln.DetectedAt, &vuln.ResolvedAt,
		&vuln.CreatedAt, &vuln.UpdatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("vulnerability not found")
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get vulnerability: %w", err)
	}

	return vuln, nil
}

// Update updates a vulnerability
func (r *VulnerabilityRepository) Update(ctx context.Context, vuln *vulnerability.Vulnerability) error {
	query := `
		UPDATE vulnerabilities SET
			status = ?, remediation = ?, resolved_at = ?, updated_at = CURRENT_TIMESTAMP
		WHERE id = ? AND user_id = ?
	`

	result, err := r.db.ExecContext(ctx, query,
		vuln.Status, vuln.Remediation, vuln.ResolvedAt, vuln.ID, vuln.UserID,
	)

	if err != nil {
		return fmt.Errorf("failed to update vulnerability: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("vulnerability not found")
	}

	return nil
}

// Delete deletes a vulnerability
func (r *VulnerabilityRepository) Delete(ctx context.Context, userID int64, id int64) error {
	query := `DELETE FROM vulnerabilities WHERE id = ? AND user_id = ?`

	result, err := r.db.ExecContext(ctx, query, id, userID)
	if err != nil {
		return fmt.Errorf("failed to delete vulnerability: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("vulnerability not found")
	}

	return nil
}

// List retrieves vulnerabilities with optional filtering
func (r *VulnerabilityRepository) List(ctx context.Context, userID int64, filter vulnerability.Filter) ([]*vulnerability.Vulnerability, error) {
	query := `
		SELECT id, user_id, scan_id, resource_id, provider, resource_type,
			cve_id, vulnerability_id, title, description,
			severity, cvss_score, cvss_vector,
			package_name, package_version, fixed_version, package_type,
			scanner_type, detection_method, status, remediation, references,
			published_date, last_modified_date, detected_at, resolved_at,
			created_at, updated_at
		FROM vulnerabilities
		WHERE user_id = ?
	`

	args := []interface{}{userID}
	query, args = r.applyFilter(query, filter, args)
	query += ` ORDER BY detected_at DESC`

	rows, err := r.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to list vulnerabilities: %w", err)
	}
	defer rows.Close()

	return r.scanVulnerabilities(rows)
}

// ListWithPagination retrieves vulnerabilities with pagination
func (r *VulnerabilityRepository) ListWithPagination(ctx context.Context, userID int64, filter vulnerability.Filter, limit, offset int) ([]*vulnerability.Vulnerability, int64, error) {
	// Get total count
	countQuery := `SELECT COUNT(*) FROM vulnerabilities WHERE user_id = ?`
	countArgs := []interface{}{userID}
	countQuery, countArgs = r.applyFilter(countQuery, filter, countArgs)

	var total int64
	err := r.db.QueryRowContext(ctx, countQuery, countArgs...).Scan(&total)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to count vulnerabilities: %w", err)
	}

	// Get paginated results
	query := `
		SELECT id, user_id, scan_id, resource_id, provider, resource_type,
			cve_id, vulnerability_id, title, description,
			severity, cvss_score, cvss_vector,
			package_name, package_version, fixed_version, package_type,
			scanner_type, detection_method, status, remediation, references,
			published_date, last_modified_date, detected_at, resolved_at,
			created_at, updated_at
		FROM vulnerabilities
		WHERE user_id = ?
	`

	args := []interface{}{userID}
	query, args = r.applyFilter(query, filter, args)
	query += ` ORDER BY detected_at DESC LIMIT ? OFFSET ?`
	args = append(args, limit, offset)

	rows, err := r.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list vulnerabilities: %w", err)
	}
	defer rows.Close()

	vulns, err := r.scanVulnerabilities(rows)
	return vulns, total, err
}

// UpdateStatus updates the status of a vulnerability
func (r *VulnerabilityRepository) UpdateStatus(ctx context.Context, userID int64, id int64, status string, resolvedAt *string) error {
	query := `
		UPDATE vulnerabilities SET
			status = ?, resolved_at = ?, updated_at = CURRENT_TIMESTAMP
		WHERE id = ? AND user_id = ?
	`

	result, err := r.db.ExecContext(ctx, query, status, resolvedAt, id, userID)
	if err != nil {
		return fmt.Errorf("failed to update vulnerability status: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("vulnerability not found")
	}

	return nil
}

// CountBySeverity counts vulnerabilities by severity
func (r *VulnerabilityRepository) CountBySeverity(ctx context.Context, userID int64) (*vulnerability.SeveritySummary, error) {
	query := `
		SELECT
			SUM(CASE WHEN severity = 'critical' THEN 1 ELSE 0 END) as critical,
			SUM(CASE WHEN severity = 'high' THEN 1 ELSE 0 END) as high,
			SUM(CASE WHEN severity = 'medium' THEN 1 ELSE 0 END) as medium,
			SUM(CASE WHEN severity = 'low' THEN 1 ELSE 0 END) as low,
			SUM(CASE WHEN severity = 'info' THEN 1 ELSE 0 END) as info,
			COUNT(*) as total
		FROM vulnerabilities
		WHERE user_id = ?
	`

	summary := &vulnerability.SeveritySummary{}
	err := r.db.QueryRowContext(ctx, query, userID).Scan(
		&summary.Critical, &summary.High, &summary.Medium, &summary.Low, &summary.Info, &summary.Total,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to count vulnerabilities by severity: %w", err)
	}

	return summary, nil
}

// CountByStatus counts vulnerabilities by status
func (r *VulnerabilityRepository) CountByStatus(ctx context.Context, userID int64) (*vulnerability.StatusSummary, error) {
	query := `
		SELECT
			SUM(CASE WHEN status = 'open' THEN 1 ELSE 0 END) as open,
			SUM(CASE WHEN status = 'patched' THEN 1 ELSE 0 END) as patched,
			SUM(CASE WHEN status = 'ignored' THEN 1 ELSE 0 END) as ignored,
			SUM(CASE WHEN status = 'false_positive' THEN 1 ELSE 0 END) as false_positive,
			SUM(CASE WHEN status = 'accepted' THEN 1 ELSE 0 END) as accepted,
			COUNT(*) as total
		FROM vulnerabilities
		WHERE user_id = ?
	`

	summary := &vulnerability.StatusSummary{}
	err := r.db.QueryRowContext(ctx, query, userID).Scan(
		&summary.Open, &summary.Patched, &summary.Ignored, &summary.FalsePositive, &summary.Accepted, &summary.Total,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to count vulnerabilities by status: %w", err)
	}

	return summary, nil
}

// GetTopVulnerabilities retrieves top N vulnerabilities ordered by severity and CVSS score
func (r *VulnerabilityRepository) GetTopVulnerabilities(ctx context.Context, userID int64, limit int) ([]*vulnerability.Vulnerability, error) {
	query := `
		SELECT id, user_id, scan_id, resource_id, provider, resource_type,
			cve_id, vulnerability_id, title, description,
			severity, cvss_score, cvss_vector,
			package_name, package_version, fixed_version, package_type,
			scanner_type, detection_method, status, remediation, references,
			published_date, last_modified_date, detected_at, resolved_at,
			created_at, updated_at
		FROM vulnerabilities
		WHERE user_id = ? AND status = 'open'
		ORDER BY
			CASE severity
				WHEN 'critical' THEN 1
				WHEN 'high' THEN 2
				WHEN 'medium' THEN 3
				WHEN 'low' THEN 4
				ELSE 5
			END,
			cvss_score DESC
		LIMIT ?
	`

	rows, err := r.db.QueryContext(ctx, query, userID, limit)
	if err != nil {
		return nil, fmt.Errorf("failed to get top vulnerabilities: %w", err)
	}
	defer rows.Close()

	return r.scanVulnerabilities(rows)
}

// ListByResource retrieves vulnerabilities for a specific resource
func (r *VulnerabilityRepository) ListByResource(ctx context.Context, userID int64, resourceID string) ([]*vulnerability.Vulnerability, error) {
	query := `
		SELECT id, user_id, scan_id, resource_id, provider, resource_type,
			cve_id, vulnerability_id, title, description,
			severity, cvss_score, cvss_vector,
			package_name, package_version, fixed_version, package_type,
			scanner_type, detection_method, status, remediation, references,
			published_date, last_modified_date, detected_at, resolved_at,
			created_at, updated_at
		FROM vulnerabilities
		WHERE user_id = ? AND resource_id = ?
		ORDER BY detected_at DESC
	`

	rows, err := r.db.QueryContext(ctx, query, userID, resourceID)
	if err != nil {
		return nil, fmt.Errorf("failed to list vulnerabilities by resource: %w", err)
	}
	defer rows.Close()

	return r.scanVulnerabilities(rows)
}

// CountByResource counts vulnerabilities for a specific resource
func (r *VulnerabilityRepository) CountByResource(ctx context.Context, userID int64, resourceID string) (int64, error) {
	query := `SELECT COUNT(*) FROM vulnerabilities WHERE user_id = ? AND resource_id = ?`

	var count int64
	err := r.db.QueryRowContext(ctx, query, userID, resourceID).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("failed to count vulnerabilities by resource: %w", err)
	}

	return count, nil
}

// CreateScan creates a new vulnerability scan record
func (r *VulnerabilityRepository) CreateScan(ctx context.Context, scan *vulnerability.VulnerabilityScan) (int64, error) {
	query := `
		INSERT INTO vulnerability_scans (
			user_id, resource_id, scan_type, status, scanner_version,
			total_vulnerabilities, critical_count, high_count, medium_count, low_count,
			scan_duration, error_message, metadata, started_at, completed_at
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	`

	result, err := r.db.ExecContext(ctx, query,
		scan.UserID, scan.ResourceID, scan.ScanType, scan.Status, scan.ScannerVersion,
		scan.TotalVulnerabilities, scan.CriticalCount, scan.HighCount, scan.MediumCount, scan.LowCount,
		scan.ScanDuration, scan.ErrorMessage, scan.Metadata, scan.StartedAt, scan.CompletedAt,
	)

	if err != nil {
		return 0, fmt.Errorf("failed to create vulnerability scan: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return 0, fmt.Errorf("failed to get last insert id: %w", err)
	}

	return id, nil
}

// GetScanByID retrieves a scan by ID
func (r *VulnerabilityRepository) GetScanByID(ctx context.Context, userID int64, id int64) (*vulnerability.VulnerabilityScan, error) {
	query := `
		SELECT id, user_id, resource_id, scan_type, status, scanner_version,
			total_vulnerabilities, critical_count, high_count, medium_count, low_count,
			scan_duration, error_message, metadata, started_at, completed_at, created_at
		FROM vulnerability_scans
		WHERE id = ? AND user_id = ?
	`

	scan := &vulnerability.VulnerabilityScan{}
	err := r.db.QueryRowContext(ctx, query, id, userID).Scan(
		&scan.ID, &scan.UserID, &scan.ResourceID, &scan.ScanType, &scan.Status, &scan.ScannerVersion,
		&scan.TotalVulnerabilities, &scan.CriticalCount, &scan.HighCount, &scan.MediumCount, &scan.LowCount,
		&scan.ScanDuration, &scan.ErrorMessage, &scan.Metadata, &scan.StartedAt, &scan.CompletedAt, &scan.CreatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("scan not found")
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get scan: %w", err)
	}

	return scan, nil
}

// UpdateScan updates a scan record
func (r *VulnerabilityRepository) UpdateScan(ctx context.Context, scan *vulnerability.VulnerabilityScan) error {
	query := `
		UPDATE vulnerability_scans SET
			status = ?, total_vulnerabilities = ?, critical_count = ?, high_count = ?, medium_count = ?, low_count = ?,
			scan_duration = ?, error_message = ?, completed_at = ?
		WHERE id = ? AND user_id = ?
	`

	result, err := r.db.ExecContext(ctx, query,
		scan.Status, scan.TotalVulnerabilities, scan.CriticalCount, scan.HighCount, scan.MediumCount, scan.LowCount,
		scan.ScanDuration, scan.ErrorMessage, scan.CompletedAt, scan.ID, scan.UserID,
	)

	if err != nil {
		return fmt.Errorf("failed to update scan: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("scan not found")
	}

	return nil
}

// ListScans retrieves scans with optional filtering
func (r *VulnerabilityRepository) ListScans(ctx context.Context, userID int64, filter vulnerability.ScanFilter) ([]*vulnerability.VulnerabilityScan, error) {
	query := `
		SELECT id, user_id, resource_id, scan_type, status, scanner_version,
			total_vulnerabilities, critical_count, high_count, medium_count, low_count,
			scan_duration, error_message, metadata, started_at, completed_at, created_at
		FROM vulnerability_scans
		WHERE user_id = ?
	`

	args := []interface{}{userID}
	query, args = r.applyScanFilter(query, filter, args)
	query += ` ORDER BY created_at DESC`

	rows, err := r.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to list scans: %w", err)
	}
	defer rows.Close()

	return r.scanScans(rows)
}

// ListScansWithPagination retrieves scans with pagination
func (r *VulnerabilityRepository) ListScansWithPagination(ctx context.Context, userID int64, filter vulnerability.ScanFilter, limit, offset int) ([]*vulnerability.VulnerabilityScan, int64, error) {
	// Get total count
	countQuery := `SELECT COUNT(*) FROM vulnerability_scans WHERE user_id = ?`
	countArgs := []interface{}{userID}
	countQuery, countArgs = r.applyScanFilter(countQuery, filter, countArgs)

	var total int64
	err := r.db.QueryRowContext(ctx, countQuery, countArgs...).Scan(&total)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to count scans: %w", err)
	}

	// Get paginated results
	query := `
		SELECT id, user_id, resource_id, scan_type, status, scanner_version,
			total_vulnerabilities, critical_count, high_count, medium_count, low_count,
			scan_duration, error_message, metadata, started_at, completed_at, created_at
		FROM vulnerability_scans
		WHERE user_id = ?
	`

	args := []interface{}{userID}
	query, args = r.applyScanFilter(query, filter, args)
	query += ` ORDER BY created_at DESC LIMIT ? OFFSET ?`
	args = append(args, limit, offset)

	rows, err := r.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list scans: %w", err)
	}
	defer rows.Close()

	scans, err := r.scanScans(rows)
	return scans, total, err
}

// GetLatestScan retrieves the most recent scan for a resource
func (r *VulnerabilityRepository) GetLatestScan(ctx context.Context, userID int64, resourceID string) (*vulnerability.VulnerabilityScan, error) {
	query := `
		SELECT id, user_id, resource_id, scan_type, status, scanner_version,
			total_vulnerabilities, critical_count, high_count, medium_count, low_count,
			scan_duration, error_message, metadata, started_at, completed_at, created_at
		FROM vulnerability_scans
		WHERE user_id = ? AND resource_id = ?
		ORDER BY created_at DESC
		LIMIT 1
	`

	scan := &vulnerability.VulnerabilityScan{}
	err := r.db.QueryRowContext(ctx, query, userID, resourceID).Scan(
		&scan.ID, &scan.UserID, &scan.ResourceID, &scan.ScanType, &scan.Status, &scan.ScannerVersion,
		&scan.TotalVulnerabilities, &scan.CriticalCount, &scan.HighCount, &scan.MediumCount, &scan.LowCount,
		&scan.ScanDuration, &scan.ErrorMessage, &scan.Metadata, &scan.StartedAt, &scan.CompletedAt, &scan.CreatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, nil // No scan found
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get latest scan: %w", err)
	}

	return scan, nil
}

// Helper functions

func (r *VulnerabilityRepository) applyFilter(query string, filter vulnerability.Filter, args []interface{}) (string, []interface{}) {
	conditions := []string{}

	if filter.Severity != "" {
		conditions = append(conditions, "severity = ?")
		args = append(args, filter.Severity)
	}
	if filter.Status != "" {
		conditions = append(conditions, "status = ?")
		args = append(args, filter.Status)
	}
	if filter.Provider != "" {
		conditions = append(conditions, "provider = ?")
		args = append(args, filter.Provider)
	}
	if filter.ResourceID != "" {
		conditions = append(conditions, "resource_id = ?")
		args = append(args, filter.ResourceID)
	}
	if filter.ResourceType != "" {
		conditions = append(conditions, "resource_type = ?")
		args = append(args, filter.ResourceType)
	}
	if filter.ScannerType != "" {
		conditions = append(conditions, "scanner_type = ?")
		args = append(args, filter.ScannerType)
	}
	if filter.CVEID != "" {
		conditions = append(conditions, "cve_id = ?")
		args = append(args, filter.CVEID)
	}
	if filter.MinCVSS != nil {
		conditions = append(conditions, "cvss_score >= ?")
		args = append(args, *filter.MinCVSS)
	}
	if filter.MaxCVSS != nil {
		conditions = append(conditions, "cvss_score <= ?")
		args = append(args, *filter.MaxCVSS)
	}

	if len(conditions) > 0 {
		query += " AND " + strings.Join(conditions, " AND ")
	}

	return query, args
}

func (r *VulnerabilityRepository) applyScanFilter(query string, filter vulnerability.ScanFilter, args []interface{}) (string, []interface{}) {
	conditions := []string{}

	if filter.ScanType != "" {
		conditions = append(conditions, "scan_type = ?")
		args = append(args, filter.ScanType)
	}
	if filter.Status != "" {
		conditions = append(conditions, "status = ?")
		args = append(args, filter.Status)
	}
	if filter.ResourceID != "" {
		conditions = append(conditions, "resource_id = ?")
		args = append(args, filter.ResourceID)
	}

	if len(conditions) > 0 {
		query += " AND " + strings.Join(conditions, " AND ")
	}

	return query, args
}

func (r *VulnerabilityRepository) scanVulnerabilities(rows *sql.Rows) ([]*vulnerability.Vulnerability, error) {
	var vulnerabilities []*vulnerability.Vulnerability

	for rows.Next() {
		vuln := &vulnerability.Vulnerability{}
		err := rows.Scan(
			&vuln.ID, &vuln.UserID, &vuln.ScanID, &vuln.ResourceID, &vuln.Provider, &vuln.ResourceType,
			&vuln.CVEID, &vuln.VulnerabilityID, &vuln.Title, &vuln.Description,
			&vuln.Severity, &vuln.CVSSScore, &vuln.CVSSVector,
			&vuln.PackageName, &vuln.PackageVersion, &vuln.FixedVersion, &vuln.PackageType,
			&vuln.ScannerType, &vuln.DetectionMethod, &vuln.Status, &vuln.Remediation, &vuln.ReferenceURLs,
			&vuln.PublishedDate, &vuln.LastModifiedDate, &vuln.DetectedAt, &vuln.ResolvedAt,
			&vuln.CreatedAt, &vuln.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan vulnerability: %w", err)
		}
		vulnerabilities = append(vulnerabilities, vuln)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows iteration error: %w", err)
	}

	return vulnerabilities, nil
}

func (r *VulnerabilityRepository) scanScans(rows *sql.Rows) ([]*vulnerability.VulnerabilityScan, error) {
	var scans []*vulnerability.VulnerabilityScan

	for rows.Next() {
		scan := &vulnerability.VulnerabilityScan{}
		err := rows.Scan(
			&scan.ID, &scan.UserID, &scan.ResourceID, &scan.ScanType, &scan.Status, &scan.ScannerVersion,
			&scan.TotalVulnerabilities, &scan.CriticalCount, &scan.HighCount, &scan.MediumCount, &scan.LowCount,
			&scan.ScanDuration, &scan.ErrorMessage, &scan.Metadata, &scan.StartedAt, &scan.CompletedAt, &scan.CreatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan scan: %w", err)
		}
		scans = append(scans, scan)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows iteration error: %w", err)
	}

	return scans, nil
}
